generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============ AUTH.JS MODELS ============

enum UserRole {
  USER
  MODERATOR
  DEVELOPER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  bio           String?   // Short profile description
  role          UserRole  @default(USER)
  isBanned      Boolean   @default(false)
  
  // Profile settings
  isProfilePublic  Boolean   @default(true)
  profileViews     Int       @default(0)
  
  accounts      Account[]
  sessions      Session[]
  mods          Mod[]     @relation("ModAuthor")
  modSubmissions ModSubmission[]
  
  // Profile relations
  viewHistory      ViewHistory[]
  downloadHistory  DownloadHistory[]
  subscriptions    Subscription[]
  badges           UserBadge[]
  socialLinks      UserSocialLink[]
  profileViewsReceived ProfileView[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============ APP MODELS ============

model Mod {
  slug              String   @id
  title             String
  version           String
  author            String   // Display name (legacy support)
  authorId          String?
  authorUser        User?    @relation("ModAuthor", fields: [authorId], references: [id])
  description       String
  status            String
  gameVersion       String
  bannerUrl         String?  // Optional banner image URL
  isSaveBreaking    Boolean  @default(false)
  features          String[]
  installationSteps String[]
  
  // JSON fields for complex structures
  links             Json
  videos            Json
  changelog         Json
  localizations     Json
  
  // Stats
  rating            Float    @default(0)
  ratingCount       Int      @default(0)
  downloads         String   @default("0")
  views             String   @default("0")
  downloadsThisMonth Int     @default(0)  // Rolling 30-day download count for Featured section
  
  screenshots       String[]
  
  // Relations
  tags              ModTag[]
  news              News[]
  translationSuggestions TranslationSuggestion[]
  
  // Profile relations
  viewHistory      ViewHistory[]
  downloadHistory  DownloadHistory[]
  subscriptions    Subscription[]
  anonymousViews     AnonymousView[]
  anonymousDownloads AnonymousDownload[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model Tag {
  id          String   @id @default(cuid())
  category    String   // "gamever", "author", "lang", "status", "newscat", "tag"
  value       String   // "1_0", "khaine", "english", "active", "release", "survival"
  displayName String
  color       String?  // Optional hex color or class name
  
  modTags     ModTag[]
  
  @@unique([category, value])
}

model ModTag {
  modId        String
  tagId        String
  
  // For language tags only: whether translation is external (with link)
  isExternal   Boolean @default(false)
  externalLink String?
  
  mod   Mod @relation(fields: [modId], references: [slug], onDelete: Cascade)
  tag   Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([modId, tagId])
}

model News {
  id            String   @id @default(cuid())
  
  // Frozen snapshot data (captured at posting time)
  modSlug       String?  // For linking to mod page
  modName       String?  // Frozen mod name (temporarily optional for migration)
  modVersion    String?  // Frozen mod version at posting time
  gameVersion   String?  // Frozen game version
  actionText    String   @default("released") // "released", "updated", etc.
  
  content       String   // Markdown content (legacy, still used)
  description   String?  // Optional short description
  date          DateTime @default(now())
  
  wipeRequired  Boolean  @default(false)
  sourceUrl     String?
  
  // Tags stored as JSON array: [{displayName, color, category}]
  tags          Json     @default("[]")
  
  // Relation to mod (for navigation only, not for syncing data)
  mod           Mod?     @relation(fields: [modSlug], references: [slug])
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model TranslationSuggestion {
  id           String   @id @default(cuid())
  modSlug      String
  modName      String
  languageCode String
  languageName String
  author       String
  link         String
  status       String   @default("pending") // "pending", "approved", "rejected"
  
  submittedAt  DateTime @default(now())
  
  // Relation to Mod
  mod          Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
}

model ModSubmission {
  id              String   @id @default(cuid())
  
  // Core mod data
  title           String
  slug            String   @unique
  version         String
  author          String   // Mod author name (can differ from submitter)
  description     String
  gameVersion     String
  bannerUrl       String?
  isSaveBreaking  Boolean  @default(false)
  features        String[]
  installationSteps String[]
  
  // JSON fields
  links           Json
  videos          Json
  changelog       Json
  localizations   Json
  screenshots     String[]
  tags            Json     // Store tag data as JSON for pending submissions
  
  // Submitter info (from Discord auth)
  submitterId     String
  submitter       User     @relation(fields: [submitterId], references: [id])
  submitterNote   String?  // Optional note to admins
  
  // Status
  status          String   @default("pending") // "pending", "approved", "rejected"
  rejectionReason String?
  
  submittedAt     DateTime @default(now())
  reviewedAt      DateTime?
}

// ============ PROFILE MODELS ============

model ViewHistory {
  id        String   @id @default(cuid())
  userId    String
  modSlug   String
  viewedAt  DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mod       Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
  
  @@unique([userId, modSlug])
}

model DownloadHistory {
  id           String   @id @default(cuid())
  userId       String
  modSlug      String
  version      String   // Track which version was downloaded
  downloadedAt DateTime @default(now())
  sessionId    String   // Prevent duplicate counts per session
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mod          Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
  
  @@unique([userId, modSlug, sessionId]) // One download per mod per session
}

model Subscription {
  id              String   @id @default(cuid())
  userId          String
  modSlug         String
  subscribedAt    DateTime @default(now())
  lastViewedAt    DateTime @default(now())
  unseenVersions  Int      @default(0)
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mod             Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
  
  @@unique([userId, modSlug])
}

// ============ ANONYMOUS VIEW TRACKING ============

model AnonymousView {
  id        String   @id @default(cuid())
  modSlug   String
  ipAddress String   // Hashed IP address for privacy
  viewedAt  DateTime @default(now())
  
  mod       Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
  
  @@unique([modSlug, ipAddress])
  @@index([viewedAt]) // For cleanup queries
}

// ============ ANONYMOUS DOWNLOAD TRACKING ============

model AnonymousDownload {
  id           String   @id @default(cuid())
  modSlug      String
  ipAddress    String   // Hashed IP address for privacy
  downloadedAt DateTime @default(now())
  
  mod          Mod      @relation(fields: [modSlug], references: [slug], onDelete: Cascade)
  
  @@unique([modSlug, ipAddress])
  @@index([downloadedAt]) // For cleanup queries
}

// ============ BADGE SYSTEM ============

model Badge {
  id          String      @id @default(cuid())
  slug        String      @unique  // "pioneer", "quality_seal", etc.
  name        String               // Display name
  icon        String               // Emoji or icon name
  description String
  rarity      String      @default("common") // common, rare, epic, legendary
  
  users       UserBadge[]
  
  createdAt   DateTime    @default(now())
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  badgeId   String
  earnedAt  DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, badgeId])
}

// ============ SOCIAL LINKS ============

model UserSocialLink {
  id       String @id @default(cuid())
  userId   String
  platform String // "discord", "steam", "youtube", "twitch", "github", "boosty"
  url      String
  
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, platform])
}

// ============ PROFILE VIEW TRACKING ============

model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String?  // null for anonymous views
  viewedId  String   // user whose profile was viewed
  viewedAt  DateTime @default(now())
  
  viewedUser User    @relation(fields: [viewedId], references: [id], onDelete: Cascade)
  
  @@index([viewedId, viewedAt])
}
